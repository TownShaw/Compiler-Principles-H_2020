<center><b><font size = 6>编译原理H HW1</font></b></center>
<p align = 'right'>肖桐 PB18000037</p>



# 习题2.

## (c). `(0 | 1)* 0 (0 | 1) (0 | 1)`

长度为3的后缀是以0开头的二进制串。

## (d). `0* 1 0* 1 0* 1 0*`

包含3个1的二进制串

# 习题3.

## (a). 包含5个元音的所有字母串，其中每个元音只出现一次且按顺序排列。

设字母表为$\Sigma = \{A, B, ..., Z, a, b, ..., z\}$，记辅音字母为：`cons --> [^aeiou]`，

则满足题意的字母串的正则表达式为：`cons* a cons* e cons* i cons* o cons* u cons*`

## (c). 某语言的注释，它是以 /* 开始并以 */ 结束的任意字符串，但它的任何前缀（本身除外）不以 */ 结尾。

记`ex1`代表除去`*`之外的所有`C`字符的集合。记`ex2`代表除去`/`之外的所有`C`字符的集合。

目标为：除去结尾的\*/，任何`*`之后不能紧跟着`/`。

写出正则表达式为：`/ \* (ex1* (\*+ (ex2))* ex1*)* \* /`，其中`\*`代表转义`*`，此时`*`并不代表闭包。

处理思想也很简单，就是将出现了`*`的情况单独提出来进行处理，使得`*`之后不能紧跟着`/`即可。

## (d). 由偶数个0和奇数个1构成的所有0和1的串。

在写出偶数个0和奇数个1构成的二进制串正则表达式之前，可以先写出具有偶数个0的二进制串的正则表达式。

具有偶数个0的二进制串的正则表达式为：`(1 | (0 (00 | 1)* 0))*`。其中`(0 (00 | 1)* 0)`表示的子串以0开头必然以0结尾，同时该子串中间的0必然成对出现，否则由于闭包运算的存在无法判断0的个数是否为偶数。同时为了避免限制：1的两边必然是0，需要把1单独提出与子串`(0 (00 | 1)* 0)`作并运算。

要再对1进行限制：限制1的个数为奇数个，可以先限制1的个数为偶数个，再在0、1均为偶数个的二进制串的开头增加一个1即可得到偶数个0、奇数个1的二进制串。

对`(1 | (0 (00 | 1)* 0))*`进行修正得到0、1均为偶数个的二进制串。首先需要将该正则表达式中出现的`1`都用`11`替换。保证当前的正则表达式代表的二进制串中0、1个数均为偶数。得到：`(11 | (0 (00 | 11)* 0))*`。

考虑到现在0、1完全对称，同时考虑到子串`01`、`10`的出现，需要将`(0 (00 | 11)* 0)`修正为：`(01 | 10) (00 | 11)* (01 | 10)`。

同时又为了避免限制：`00`两边必为`10`或`01`，需要把`00`从闭包中提出进行并运算。

最终得到：`(00 | 11 | (01 | 10) (00 | 11)* (01 | 10))*`。这便是0、1均为偶数个的二进制串的正则表达式。

最后再来构造偶数个0、奇数个1的二进制串的正则表达式。这可以分为两类：

1. 以1开头的二进制串。则后面紧跟一个0、1均为偶数个的二进制串，

   故得到：`1 (00 | 11 | (01 | 10) (00 | 11)* (01 | 10))*`

2. 以0开头的二进制串。则在经过有限个0、1均为偶数个的二进制串后必有子串`01`或`10`，将0的个数变为偶数、1的个数变为奇数。再后面可以再接一个0、1均为偶数个的二进制串。

   故得到：`0 (00 | 11 | (01 | 10) (00 | 11)* (01 | 10))* (01 | 10) (00 | 11 | (01 | 10) (00 | 11)* (01 | 10))*`

将上述二者作并运算即可得到偶数个0、奇数个1的二进制串的正则表达式为：

`(1 (00 | 11 | (01 | 10) (00 | 11)* (01 | 10))*) | (0 (00 | 11 | (01 | 10) (00 | 11)* (01 | 10))* (01 | 10) (00 | 11 | (01 | 10) (00 | 11)* (01 | 10))*)`

或若记`even --> (00 | 11 | (01 | 10) (00 | 11)* (01 | 10))*`，`even`表示0、1均为偶数个的二进制串，则可更清楚地看到：

`(1 even) | (0 even (01 | 10) even)`